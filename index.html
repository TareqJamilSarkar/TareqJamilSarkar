<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Puzzle Reveal — TAREQ JAMIL SARKAR</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0b1220;
      --card:#0f1724;
      --accent:#7dd3fc;
      --text:#e6f1ff;
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Arial;}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,var(--bg),#07101a);color:var(--text);padding:24px;}
    .wrap{width:940px;max-width:95%;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:14px; padding:18px; box-shadow: 0 8px 30px rgba(3,6,23,0.6);}
    h1{margin:6px 0 12px;font-size:20px;letter-spacing:1px;}
    .board{position:relative;height:220px;background:transparent;border-radius:12px;overflow:hidden;display:flex;align-items:center;justify-content:center;}
    .controls{display:flex;gap:10px;margin-top:14px;align-items:center;}
    button{background:var(--accent);color:#041022;border:0;padding:10px 14px;border-radius:10px;font-weight:700;cursor:pointer;box-shadow:0 6px 16px rgba(27,75,91,0.18);}
    .hint{color:#9fb0c8;font-size:13px;}
    /* each tile container */
    .tile {
      position:absolute;
      width:var(--tw);
      height:var(--th);
      border-radius:8px;
      box-shadow: 0 8px 20px rgba(2,8,20,0.6);
      transition: transform 550ms cubic-bezier(.2,.9,.2,1), box-shadow 200ms;
      will-change: transform;
      cursor:grab;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .tile:active { cursor:grabbing; }
  </style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Puzzle reveal for TAREQ JAMIL SARKAR">
    <h1>Puzzle Reveal — <strong>TAREQ JAMIL SARKAR</strong></h1>

    <div class="board" id="board" aria-hidden="false"></div>

    <div class="controls">
      <button id="shuffleBtn">Shuffle</button>
      <div class="hint">Click Shuffle to scramble — click Solve to auto-assemble.</div>
    </div>
  </div>

  <script>
    /*****************************************************************************
     * Interactive puzzle
     * - Draws the name to an offscreen canvas
     * - Slices into NxM tiles
     * - Animates tiles from random positions into correct positions (solve)
     * - Shuffle places tiles randomly
     *
     * Works locally or when hosted (e.g., GitHub Pages). No external assets.
     *****************************************************************************/
    (function(){
      const TEXT = "TAREQ JAMIL SARKAR";
      const board = document.getElementById('board');
      const shuffleBtn = document.getElementById('shuffleBtn');

      const W = 900, H = 220;         // resolution for the drawn text area
      const cols = 16;               // horizontal tiles
      const rows = 1;                // make it one long row (fits name)
      const tileW = Math.floor(W / cols);
      const tileH = Math.floor(H / Math.max(1, rows));

      // set CSS variables for dimensions
      board.style.width = W + 'px';
      board.style.height = H + 'px';

      // offscreen canvas for rendering text
      const source = document.createElement('canvas');
      source.width = W;
      source.height = H;
      const sctx = source.getContext('2d');

      // draw stylized text
      function drawText() {
        sctx.clearRect(0,0,W,H);
        // background subtle gradient for the text image (gives nicer slices)
        const g = sctx.createLinearGradient(0,0,0,H);
        g.addColorStop(0, '#ffffff'); g.addColorStop(1, '#dbeeff');

        // big text
        sctx.textBaseline = 'middle';
        sctx.textAlign = 'center';
        const fontSize = 56;
        sctx.font = `800 ${fontSize}px "Segoe UI", Roboto, Arial, sans-serif`;
        // shadow/glow
        sctx.fillStyle = '#e6f4ff';
        sctx.shadowColor = 'rgba(125,211,252,0.08)';
        sctx.shadowBlur = 18;
        sctx.fillText(TEXT, W/2, H/2 - 6);

        // add bright stroke to accent edges
        sctx.lineWidth = 2.5;
        sctx.strokeStyle = 'rgba(255,255,255,0.08)';
        sctx.strokeText(TEXT, W/2, H/2 - 6);

        // tiny inner gradient overlay
        sctx.globalCompositeOperation = 'lighter';
        sctx.fillStyle = 'rgba(255,255,255,0.03)';
        sctx.fillRect(0, H/2 - fontSize/2, W, fontSize/2);
        sctx.globalCompositeOperation = 'source-over';
      }

      drawText();

      // create tile objects
      const tiles = [];
      for (let r=0;r<rows;r++){
        for (let c=0;c<cols;c++){
          const x = c*tileW;
          const y = r*tileH;
          const tileCanvas = document.createElement('canvas');
          tileCanvas.width = tileW;
          tileCanvas.height = tileH;
          const tctx = tileCanvas.getContext('2d');
          // draw slice of source onto tile
          tctx.drawImage(source, x, y, tileW, tileH, 0, 0, tileW, tileH);

          // element to put on screen
          const el = document.createElement('div');
          el.className = 'tile';
          el.style.setProperty('--tw', tileW + 'px');
          el.style.setProperty('--th', tileH + 'px');
          el.style.width = tileW + 'px';
          el.style.height = tileH + 'px';
          el.style.left = (x + (W - board.clientWidth)/2) + 'px'; // we'll use transforms instead of left for animation
          el.style.top = y + 'px';

          // put image as background (use data URL)
          const dataUrl = tileCanvas.toDataURL('image/png');
          el.style.backgroundImage = `url(${dataUrl})`;
          el.style.backgroundSize = `${tileW}px ${tileH}px`;
          el.style.backgroundPosition = '0 0';
          el.dataset.cx = x;
          el.dataset.cy = y;
          el.dataset.col = c;
          el.dataset.row = r;
          board.appendChild(el);

          tiles.push({
            c, r, x, y, el,
            tx: x, ty: y,
            // random start pos values (off-canvas scattered)
            sx: (Math.random()*2-1) * (W*0.8),
            sy: (Math.random()*2-1) * (H*1.2),
            rot: (Math.random()*2-1) * 60
          });
        }
      }

      // position tiles initially scattered
      tiles.forEach(t=>{
        t.el.style.transform = `translate(${t.sx}px, ${t.sy}px) rotate(${t.rot}deg) scale(1.05)`;
      });

      // animation helpers
      function animateTo(tile, target, duration=900, easing=(t)=>{ // easeOutCubic
        return new Promise(res=>{
          const start = performance.now();
          const from = {x: tile.currentX ?? tile.sx, y: tile.currentY ?? tile.sy, r: tile.currentR ?? tile.rot, s: tile.currentS ?? 1.05};
          const to = {x: target.x, y: target.y, r: target.r ?? 0, s: target.s ?? 1.0};

          function loop(now){
            const t = Math.min(1, (now - start)/duration);
            const tt = 1 - Math.pow(1-t,3); // easeOut
            const nx = from.x + (to.x - from.x)*tt;
            const ny = from.y + (to.y - from.y)*tt;
            const nr = from.r + (to.r - from.r)*tt;
            const ns = from.s + (to.s - from.s)*tt;
            tile.el.style.transform = `translate(${nx}px, ${ny}px) rotate(${nr}deg) scale(${ns})`;
            tile.currentX = nx; tile.currentY = ny; tile.currentR = nr; tile.currentS = ns;
            if (t < 1) requestAnimationFrame(loop);
            else res();
          }
          requestAnimationFrame(loop);
        });
      }

      // solve: animate all tiles to correct positions (tx,ty)
      let busy = false;
      async function solve() {
        if (busy) return;
        busy = true;
        const promises = [];
        // stagger them for elegance
        tiles.forEach((t,i)=>{
          const left = t.tx - t.sx; // target relative to initial scatter origin (we animate to zero offset)
          // But we need the target transform as pixel offsets relative to their current scattered positions.
          // We'll animate each tile to (tx,ty) relative to the board center (the canvas drawing is full width).
          // We'll compute target translate as (tx,ty).
          const target = { x: t.tx, y: t.ty, r: 0, s: 1.0 };
          // small randomized duration and delay
          const delay = i * 40;
          promises.push(new Promise(resolve => setTimeout(()=> animateTo(t, target).then(resolve), delay)));
        });
        await Promise.all(promises);
        busy = false;
      }

      // shuffle: scatter randomly
      async function scramble() {
        if (busy) return;
        busy = true;
        const promises = tiles.map((t,i) => {
          const target = { x: (Math.random()*2-1) * (W*0.8), y: (Math.random()*2-1) * (H*1.2), r: (Math.random()*2-1)*60, s: 1.02 };
          const delay = i * 18;
          return new Promise(resolve => setTimeout(()=> animateTo(t, target, 850).then(resolve), delay));
        });
        await Promise.all(promises);
        busy = false;
      }

      // helper to move tiles exactly to their final on-board positions (centered)
      // We have to correct for board placement relative to canvas; tile.tx,ty are in the canvas coordinate system,
      // so we set transform translate to those values to align visually.
      // Provide an initial "assemble" small animation on load
      (async function initialAssemble(){
        await solve();
        // tiny wiggly entrance
        tiles.forEach((t,i)=>{
          t.el.style.transition = 'transform 420ms cubic-bezier(.2,.9,.2,1)';
          t.el.style.transform += ' scale(1.01)';
          setTimeout(()=> t.el.style.transform = `translate(${t.tx}px, ${t.ty}px) rotate(0deg) scale(1)`, 60 + i*12);
        });
      })();

      // button toggles
      let solved = true;
      shuffleBtn.addEventListener('click', async ()=>{
        if (busy) return;
        if (solved) {
          shuffleBtn.disabled = true;
          shuffleBtn.textContent = 'Shuffling...';
          await scramble();
          shuffleBtn.textContent = 'Solve';
          shuffleBtn.disabled = false;
          solved = false;
        } else {
          shuffleBtn.disabled = true;
          shuffleBtn.textContent = 'Solving...';
          await solve();
          shuffleBtn.textContent = 'Shuffle';
          shuffleBtn.disabled = false;
          solved = true;
        }
      });

      // small hover shine effect: when mouseover board, give tiles gentle lift
      board.addEventListener('mousemove', (ev)=>{
        const rect = board.getBoundingClientRect();
        const mx = ev.clientX - rect.left;
        const my = ev.clientY - rect.top;
        tiles.forEach(t=>{
          const dx = (mx - (t.tx + tileW/2));
          const dy = (my - (t.ty + tileH/2));
          const dist = Math.sqrt(dx*dx + dy*dy);
          const lift = Math.max(-8, -Math.min(12, (12 - dist/20)));
          // only adjust small amount
          if (t.currentX !== undefined) {
            t.el.style.transform = `translate(${t.currentX}px, ${t.currentY + lift}px) rotate(${t.currentR}deg) scale(${t.currentS})`;
          }
        });
      });

      board.addEventListener('mouseleave', ()=> {
        tiles.forEach(t=>{
          if (t.currentX !== undefined) {
            t.el.style.transform = `translate(${t.currentX}px, ${t.currentY}px) rotate(${t.currentR}deg) scale(${t.currentS})`;
          }
        });
      });

      // accessibility: keyboard toggle
      document.addEventListener('keydown', (e)=>{
        if (e.key === ' ' || e.key === 'Enter') {
          e.preventDefault();
          shuffleBtn.click();
        }
      });

    })();
  </script>
</body>
</html>
